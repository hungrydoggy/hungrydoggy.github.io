# Flutter 겉 핥기
자동으로 만들어진 프로젝트 위에서,  
겉 핥기 식의 Flutter 탐사를 시작하겠습니다.  

## 파일과 폴더 구조
일단 Android Studio의 왼쪽 부분에 있는 네비게이터를 살펴 봅시다.  
우리가 만든 **my_eshop** 이라는 최상단 폴더를 펼치면 다음과 같은 구조가 나옵니다.  
![navigator](images/navigator.png)  

각자가 자신의 역할을 가지고 존재하겠지만,  
일단 지금은 제가 빨간줄을 그어놓은, 딱 두개만 알면 됩니다.  
- **lib 폴더**
  - 소스코드들(dart 파일)의 최상위 폴더
  - 현재는 자동 생성된, main.dart 밖에 없다
  - 앞으로 작성하는 모든 소스코드를 여기에 넣는다
- **pubspec.yaml**
  - 프로젝트에 관한 설정 파일
  - 프로젝트 이름 및 버전 등등의 정보
  - 이 파일을 수정하여, package manager에서 자동으로 모듈을 다운받을 수 있다
  - 이미지, 폰트 등의 asset 설정도 여기에서 한다

## 코드를 수정해 볼까요?
일단 작은 것들을 건드려 보면서 감을 잡는것이 중요합니다.  
일단 앱을 실행합니다. 폰으로 하든, VM으로 하든 상관 없습니다.  
그리고 자동으로 작성되어 있는, main.dart 파일을 더블 클릭하여 열어 봅시다.  

### 타이틀 바꿔보기
일단 제일 눈에 잘 들어오는, 앱의 최 상단에 있는 "Flutter Demo Home Page" 를 바꿔보겠습니다.  
main.dart 코드를 연 상태에서, `Ctrl+F` 를 눌러서 "Flutter Demo Home Page"를 검색해 보세요.  
23번줄의 
``` dart
home: MyHomePage(title: 'Flutter Demo Home Page'),
```
부분이 보이실 겁니다. 이 부분을 내 마음대로 바꿔 봅시다.  
``` dart
home: MyHomePage(title: 'This is my first Flutter App'),
```
저는 이렇게 바꿨습니다. `Ctrl+S`를 눌러서 저장해 볼까요?  
짜잔! 추가적인 빌드가 필요 없이, 타이틀 내용이 순식간에 바뀌었습니다.  

이렇게 빌드 없이 바로 갱신 되는 것을 Flutter에서 **Hot Reload**라고 부릅니다.  
이 **Hot Reload**가, Flutter를 매력있게 만드는 중요한 특징 중 하나 입니다.  
앞으로도 편리한 **Hot Reload**를 잘 활용해 봅시다.  

### + 버튼 옆에 - 버튼도 만들어 보기
타이틀만 바꾸는 것 만으로는 전혀 감이 안오는 것 같습니다.  
좀 더 복잡한걸 해봐야 겠습니다.  

지금은 + 버튼을 누르면 가운데 숫자가 증가하도록 되어 있네요.  
그럼 우리는 - 버튼을 추가해서, 가운데 숫자를 감소시키도록 해봅시다.  

일단 + 버튼이 어떻게 추가되어있는지를 찾아서 흉내내 볼까요?  


## 코드를 분석해 봅시다
main.dart 파일을 더블 클릭하여 열어 봅시다.  

### main 함수
첫 번째 줄은 import이니 넘어가고,  
세 번째 줄을 볼까요?
``` dart
void main() => runApp(MyApp());
```
위 형태는 lambda 함수라고 불리는 형태 인데, 간소화된 함수 형태라고 생각하셔도 좋습니다.  
위 코드는 아래 코드와 완전히 동일합니다.  
``` dart
// 일반적인 함수 Syntax로 작성한 main 함수
void main () {
  return runApp(MyApp());
}
```
Dart 라는 언어는 실행시에 main 함수가 처음으로 불리도록 약속되어 있습니다.  
main 함수에서는 `runApp` 이라는 함수를 부르고 있는데요.  
이 `runApp`은 Flutter에서 제공하는 함수입니다.  
이 함수에 위젯을 파라미터로 넣어서 부르면, 그 위젯으로 Flutter 앱이 시작됩니다.  

이 코드에서는 `MyApp()`을 파라미터로 넘긴 것을 보면,  
`MyApp()`이 위젯이라는 것을 알 수 있습니다.  

### MyApp 위젯
Flutter는 모든 것이 위젯 입니다.  
텍스트도 위젯, 이미지도 위젯, 탭바도 위젯,...  
여러 위젯들이 트리구조로, 즉 부모자식 관계를 이루어서 구성 됩니다.  

외우거나 유심히 볼 필요는 없지만, 지금 프로젝트의 위젯 트리 구조는 다음과 같습니다.  

![helloworld-widget-tree](images/helloworld-widget-tree.png)  

최상단 노드의 이름이 **MyApp** 이라고 쓰여있죠?  
즉 현재는 **MyApp**이 루트 위젯 입니다.  

코드의 5번째 줄을 보시죠.  
``` dart
class MyApp extends StatelessWidget {
  // ...
}
```
**MyApp**은 **StatelessWidget**이라는 클래스를 상속받은 클래스라는걸 알 수 있습니다.  
아직은 **StatelessWidget**이 뭔지 정확히 알 수 없지만,  
일단 다른 곳에 선언이 안되어있으니, **Flutter에서 제공하는 클래스**라는 것을 알 수 있고요.  
이름에 Widget이 들어가니, **"아, 이게 위젯의 한 종류 구나"** 정도는 알 수 있습니다.  
그런데 MyApp이 StatelessWidget을 상속 받았으니, **MyApp도 위젯**이라는 것도 알 수 있겠죠.  

Dart에서는, 클래스의 인스턴스를 생성할때 **"new 연산자"를 생략할 수 있습니다**  
즉, 아래 두 코드는 완전히 같은 코드 입니다.
``` dart
runApp(MyApp());

runApp(new MyApp());
```

그래서 아까 `runApp(MyApp())` 이라는 코드를 통해 앱을 실행시킬 수 있었습니다.  
> new 연산자가 생략된 것이기 때문에, 이는 다음과 같이 해석할 수 있습니다.  
> "runApp 함수를 호출하는데, 파라미터로 MyApp 클래스의 인스턴스를 생성하여 넘겼다."  
